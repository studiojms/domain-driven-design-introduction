<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />
    <meta name="description" content="DDD - Domain Driven Design" />
    <meta name="author" content="Jefferson Mariano de Souza" />

    <title>DDD - Domain Driven Design</title>

    <link rel="stylesheet" href="assets/reset.css" />
    <link rel="stylesheet" href="assets/reveal.css" />
    <link rel="stylesheet" href="assets/theme/league.css" id="theme" />
    <!-- <link rel="stylesheet" href="assets/theme/black.css" id="theme"> -->

    <!-- Theme used for syntax highlighted code -->
    <link rel="stylesheet" href="assets/plugin/highlight/monokai.css" id="highlight-theme" />
  </head>
  <body>
    <div class="reveal">
      <div class="slides">
        <section data-background="img/ddd-embratel.jpeg" data-background-opacity="0.3">
          <h2>Domain Driven Design</h2>
          <br />
          <p>Jefferson Mariano de Souza</p>
        </section>
        <section data-background="img/filosofia.jpg" data-background-opacity="0.3">
          <h2>Definição</h2>

          <section>
            <ul>
              <li class="fragment fade-up">forma de diminuir a complexidade do coração do sistema</li>
              <li class="fragment fade-up">delimitar contextos</li>
              <li class="fragment fade-up">lado mais filosófico do que técnico</li>
            </ul>
          </section>
          <section>
            <h3>forma de diminuir a complexidade do coração do sistema</h3>
            <ul>
              <li class="fragment fade-up">resolver o problema do negócio</li>
              <li class="fragment fade-up">resolver a parte principal do sistema</li>
            </ul>
          </section>
          <section>
            <ul>
              <li class="fragment fade-up">utiliza diversos design patterns, mas não está acoplado a nenhum</li>
              <li class="fragment fade-up">Não se trata de criar camadas, entidades, repositórios etc</li>
              <li class="fragment fade-up">Design guiado pelo domínio (razão da aplicação existir)</li>
            </ul>
          </section>
        </section>
        <section data-background="img/ddd-no-background.png" data-background-opacity="0.1">
          <h2>História</h2>
          <p>Criado em 2003, por Eric Evans</p>

          <q>DDD é algo mutável, pode evoluir com o passar do tempo</q>
        </section>
        <section>
          <img src="img/ddd-book.jpg" height="600" />
        </section>
        <section data-background="img/complex.jpg" data-background-opacity="0.1">
          <h2>Quando usar?</h2>
          <ul>
            <li class="fragment fade-up">aplicações complexas</li>
            <li class="fragment fade-up">sistemas que uma decisão errada pode impactar o projeto inteiro</li>
          </ul>
        </section>
        <section data-background="img/business.jpg" data-background-opacity="0.2">
          <h2>Domínio</h2>
          <ul>
            <li class="fragment fade-up">o coração do negócio (razão do negócio existir)</li>
            <li class="fragment fade-up">tem base em um conjunto de ideias, conhecimento e processos</li>
            <li class="fragment fade-up">sem domínio, os processos auxiliares não tem muita utilidade</li>
          </ul>
        </section>
        <section data-background="img/problem.jpg" data-background-opacity="0.2">
          <h3>Para resolver o problema de negócio, não precisamos necessariamente de código</h3>
          <div class="fragment fade-up">Mas sim...</div>
        </section>
        <section data-background="img/comunicacao.jpg" data-background-opacity="0.2">
          <h2>Comunicação</h2>
          <section>
            <ul>
              <li class="fragment fade-up">conseguir falar com todos os envolvidos em uma mesma linguagem</li>
              <li class="fragment fade-up">conversar entre todas as áreas, com todos os envolvidos no problema</li>
            </ul>
          </section>
          <section>
            <h3>linguagem ubíqua</h3>
            <img src="img/ubiquitous-1.png" />
          </section>
          <section>
            <h3>linguagem ubíqua</h3>
            <ul>
              <li class="fragment fade-up">é a linguagem falada no dia a dia no contexto da empresa</li>
              <li class="fragment fade-up">utiliza as terminologias da realidade do negócio</li>
              <li class="fragment fade-up">
                devs precisam conhecer a fundo a linguagem, para conseguir modelar o sistema para representar o negócio
                real
              </li>
            </ul>
          </section>
          <section>
            <h3>linguagem ubíqua</h3>
            <div>O que é <q>Cliente</q>?</div>
            <ul>
              <li class="fragment fade-up">quem loga no sistema?</li>
              <li class="fragment fade-up">quem compra algum produto?</li>
              <li class="fragment fade-up">quem contrata um serviço?</li>
            </ul>
          </section>
          <section>
            <h3>linguagem ubíqua</h3>
            <img src="img/ubiquitous-2.png" />
          </section>
          <section>
            <h3>Domain Expert</h3>
            <img src="img/expert.png" />
          </section>
          <section>
            <h3>Domain Expert</h3>
            <ul>
              <li class="fragment fade-up">quem conhece profundamente o negócio</li>
              <li class="fragment fade-up">quem vive o dia a dia do negócio</li>
            </ul>
          </section>
        </section>
        <section data-background="img/dominio.jpg" data-background-opacity="0.2">
          <h2>Identificar subdomínios</h2>
          <section>
            <p>Com a comunicação em ordem, o próximo passo é identificar subdomínios</p>
          </section>
          <section>
            <p>Domínio é o core business, o coração do problema</p>
          </section>
          <section>
            <h3>Subdomínio</h3>
            <ul>
              <li class="fragment fade-up">subáreas do sistema que possuem complexidades e diversas regras</li>
              <li class="fragment fade-up">refle muito em como a empresa vai funcionar</li>
            </ul>
            <aside class="notes">
              ex: netflix
              <ul>
                <li>dominio principal: video</li>
                <li>sub dominio: negociar licenciamento com empresas (Warner, Paramount)</li>
                <li>sub dominio: fechar contratos</li>
                <li>sub dominio: transcoding do video</li>
              </ul>
            </aside>
          </section>
        </section>
        <section>
          <h2>Identificar contextos da empresa</h2>
          <section>
            <ul>
              <li class="fragment fade-up">cada contexto tem sua própria forma, sua propria linguagem</li>
              <li class="fragment fade-up">as complexidades mudam de acordo com cada uma das areas</li>
              <li class="fragment fade-up">lugares que usam o mesmo nome para coisas diferentes</li>
              <li class="fragment fade-up">ou coisas diferentes utilizando o mesmo nome</li>
            </ul>
          </section>
        </section>
        <section>
          <h2>Comunicação entre os contextos</h2>
          <ul>
            <li class="fragment fade-up">quais são as partes do dominio principal</li>
            <li class="fragment fade-up">quais são os dominios auxiliares?</li>
            <li class="fragment fade-up">relações entre os Domínios</li>
          </ul>
        </section>
        <section>
          <h2>Mapa de contexto</h2>
          <ul>
            <li class="fragment fade-up">mapa que detalha a relação entre os dominios</li>
            <li class="fragment fade-up">possibilita uma visão geral do sistema</li>
            <li class="fragment fade-up">separar os pontos de complexidade</li>
            <li class="fragment fade-up">identificar pontos auxiliares para o sistema</li>
            <li class="fragment fade-up">conseguir atacar o que realmente importa</li>
          </ul>
        </section>
        <section>
          <h2>Resumindo: Pilares do DDD</h2>
          <ul>
            <li class="fragment fade-up">linguagem ubíqua</li>
            <li class="fragment fade-up">contextos delimitados (bounded contexts) - até onde vai a reponsabilidade de cada parte do sistema</li>
            <li class="fragment fade-up">mapas de contexto</li>
          </ul>
        </section>
        <section>
          <h2>E no código?</h2>
          <section>
            <ul>
              <li class="fragment fade-up">Entidades</li>
              <li class="fragment fade-up">Value Objects</li>
              <li class="fragment fade-up">Aggregations</li>
              <li class="fragment fade-up">Repositorios</li>
              <li class="fragment fade-up">Services</li>
            </ul>
          </section>
          <section>
            <h5>tudo baseado na linguagem criada antes de chegar no código</h5>
            <h5>só começa o código quando a complexidade for definida e entendida</h5>
          </section>
          <section>
            <h5>a maior parte do esforço vai na parte de entender a complexidade</h5>
          </section>
        </section>
        <section>
          <h2>Entidade</h2>
          <section>
            <ul>
              <li class="fragment fade-up">algo unico no sistema, com representatividade no negócio</li>
              <li class="fragment fade-up">existe no meu sistema, pode mudar seu estado e possui uma identidade unica</li>
              <li class="fragment fade-up">este item geralmente possui um id (que não existe por existir, mas para diferenciar um do outro)</li>
              <li class="fragment fade-up">é um dominio rico, tem uma razão de existir</li>
              <li class="fragment fade-up">
                entidade não existe para ser persistida... persistencia é outro problema que acaba sendo resolvido (em
                algumas linguagens) junto
              </li>
            </ul>
            <aside>
              os mais puristas dizem que entidade não deveria ter os gets/sets, mas sim suas acoes (historicamente, a
              ideia de gets/sets vem de modelar o sistema com base no banco...)
            </aside>
          </section>
          <section>
            <h6>
              Cada contexto tem as proprias entidades. Posso ter a entidade "Cliente" em mais de um contexto, ou uma
              entidade pode aparecer em diversos contextos com nomes diferentes
            </h6>
          </section>
        </section>
        <section>
          <h2>Exemplo: Cadastro de usuário</h2>

          <section>
            <h5>Qual o tipo de dado?</h5>
            <ul class="fragment fade-up">
              <li>nome</li>
              <li>cpf</li>
              <li>email</li>
            </ul>
          </section>
        </section>
        <section>
          <h2>Objeto de Valor (Value Object - VO)</h2>
          <ul>
            <li class="fragment fade-up">classe que não tem identidade unica, é usada como auxiliar</li>
            <li class="fragment fade-up">(parar de usar tipos primitivos para tudo)</li>
            <li class="fragment fade-up">CPF -> possui validação própria</li>
            <li class="fragment fade-up">E-Mail -> possui validação própria</li>
          </ul>
        </section>
        <section>
          <h2>Aggregates</h2>
          <section>
            <ul>
              <li class="fragment fade-up">Relação Pedido x item</li>
              <li class="fragment fade-up">Pedido possui n itens</li>
              <li class="fragment fade-up">Item só existe se existir pedido</li>
            </ul>
          </section>
          <section>
            <h5>Pedido: Raiz, por onde o processo começa</h5>
            <ul>
              <li class="fragment fade-up">Pedido: Root Aggregate</li>
            </ul>
          </section>
        </section>
        <section>
          <h2>Repositório</h2>
          <section>
            <ul>
              <li class="fragment fade-up">Parte responsável por persistir as entidades</li>
              <li class="fragment fade-up">geralmente existe apenas para o aggregate root</li>
              <li class="fragment fade-up">ex: eu persisto o pedido, não o item</li>
            </ul>
          </section>
        </section>
        <section>
          <h2>Service</h2>
          <ul>
            <li class="fragment fade-up">Operação que não é uma parte natural de uma Entidade ou Objeto de Valor</li>
            <li class="fragment fade-up">Geralmente relacionada a um conceito de domínio</li>
            <li class="fragment fade-up">É uma operação definida em termos de outros elementos do modelo</li>
            <li class="fragment fade-up">Geralmente é uma operação stateless</li>
          </ul>
        </section>
        <section data-background="img/ddd.gif" data-background-opacity="0.5">
          <h1>Obrigado</h1>
        </section>
      </div>
    </div>
    <!-- 
- se a netflix não tivesse video, seria inutil

identificar a parte central do sistema


DDD - forma de diminuir a complexidade do coração do sistema
resolver o problema do negocio
resolver a parte principal do sistema



DDD não é apenas criar camadas, criar entidade, value objects etc


Design guiado pelo domínio (razão da aplicação existir)


Eric Evans - 2003


Para resolver o problema de negocio, não precisamos necessariamente de codigo

mas sim

1. Comunicação - conseguir falar uma linguagem universal (ubíqua)
 - conversar entre todas as areas, com todos os envolvidos no problema


Exemplo
 Sistema de locadora de veiculos

- aparentemente é simples: escolher o carro, fazer o pagamento e pronto

domain expert possui a visão detalhada

- há seguro, identificacão do locador
- varios detalhes intrinsecos ão negocio

domain expert: quem conhece profundamente, quem vive aquele negócio


quando td mundo está entendo td, se comunicando bem:
2. Identificar Subdomínios

subáreas do sistema que possuem complexidade e muitas regras

ex: netflix
dominio principal: video
sub dominio: negociar licenciamento com empresas (Warner, Paramount)
sub dominio: fechar contratos
sub dominio: transcoding do video


sub dominio: refle muito no como a empresa vai funcionar


linguagem muito diferente de acordo com a situacão e o contexto

ex:
cliente:
- quem contrata os serviços
- depende do ponto de vista, cliente é a propria empresa quando negocia com fornecedores

3. Identificar contextos da empresa

- cada contexto tem sua própria forma, sua propria linguagem

as complexidades mudam de acordo com cada uma das areas


identificar contextos: (lugares que usam o mesmo nome para coisas diferentes, ou coisas diferentes utilizando o mesmo nome)


4. definir a comunicação entre os contextos

- quais são as partes do dominio principal
- quais são os dominios auxiliares?


identificar relações entre os dominios

5. context map

mapa que detalha a relação entre os dominios

- possibilita uma visão geral do sistema
- separar os pontos de complexidade
- identificar pontos auxiliares para o sistema
- conseguir atacar o que realmente importa


E no código

Entidades
Value Objects
Aggregations
repositorios
servicos

(tudo baseado na linguagem criada antes de chegar no código)


só começa o código quando a complexidade for definida e entendida

não é crud, sistema simples

geralmente DDD é usado para sistemas grandes, sistemas que, uma decisão errada, vai impactar o projeto inteiro


a maior parte do esforço vai na parte de entender a complexidade



independente de linguagem ou framework da moda:

- entidades
algo unico no sistema, algo com unicidade
existe no meu sistema, pode mudar seu estado e possui uma identidade unica

este item geralmente possui um id (que não existe por existir, mas para diferenciar um do outro)

os mais puristas dizem que entidade não deveria ter os gets/sets, mas sim suas acoes
(historicamente, a ideia de gets/sets vem de modelar o sistema com base no banco...)

entidade é um dominio rico, tem uma razão de existir


Video: filme -> alugar, mudar preco, dar um desconto


entidade não existe para ser persistida... persistencia é outro problema que acaba sendo resolvido (em algumas linguagens) junto


ex:
cadastro de pessoa
Nome, CPF (que tipo de dado usar?)

String? Numerico?

Deveria ser um tipo unico, não um tipo primitido

=> Value Object

classe que não tem identidade unica, é usada como auxiliar

(parar de usar tipos primitivos para tudo)

ex: CPF -> possui validação própria

exemplos: email, endereço etc


Relação Pedido x Item

Item não pode existir sem o pedido

- Aggregates

Pedido: Raiz, pode onde o processo começa


geralmente o repositório (onde vai salvar) existe apenas para o aggregate root

eu persisto o pedido, não o item


Cada contexto tem as proprias entidades. Posso ter a classe Cliente em mais de um contexto, ou uma entidade pode aparecer em diversos contextos com nomes diferentes





relação com microservices

geralmente, cada contexto delimitado é um candidato a ser um microserviço


DDD - pensa em como resolver o problema do negócio
não tem como foco resolver o problema do seu banco de dados (mapeamento ORM etc)


     -->
    <!-- 
Domain Driven Design

# introducão

não é apenas criar camadas dentro da aplicação

Forma de organizar a aplicação
- delimitar contextos
- lado mais filosófico do que técnico

# criado quando

- Eric Evans, 2003

DDD é algo mutável, pode evoluir com o passar do tempo
ex: faz muito sentido atualmente com ideia de microserviços

- utilizado para aplicações complexas
- fácil de entender, difícil de aplicar (chavão)

- utiliza diversos design patterns, mas não está acoplado a nenhum

utilizar camadas no código não quer dizer que está usando DDD


# o que é ddd

- conjunto de principios com foco em
- dominio
- exploracão de modelos
- definir linguagem ubiqua baseada em um contexto

# dominio (razão do software existir)

o coração do negócio (razão do negócio existir)
tem base em um conjunto de ideias, conhecimento e processos

sem domínio, os processos auxiliares não tem muita utilidade

# exploracão de modelos

no DDD, devs fazem parte do processo de entender o negócio e todos os seus modelos (não simplesmente entrevistar especialistas)
- dev participar de todo o processo (contato com domain experts)

não faz muito sentido utilizar em aplicações pequenas (pois são simples)
- ERP - sistema com diversas áreas, diversos contextos
- sistemas grandes, com muitas coisas


# linguagem ubiqua (ponto mais importante)

- é a linguagem falada no dia a dia no contexto da empresa
- utiliza as terminologias da realidade do negócio

- dev precisa conhecer a fundo a linguagem, para conseguir modelar o sistema para representar o negócio real

(não ter a terminologia definida é muito fácil de levar o sistema ão fracasso)

ex: cliente - o que é?
quem loga no sistema? quem compra algum produto? quem contrata um serviço?


# pilares do DDD

- linguagem ubiqua
- bounded contexts (contextos delimitados) - até onde vai a reponsabilidade de cada parte do sistema
- context maps (depois de delimitados os contextos, criar um mapa que exiba a relação entre os contextos)

(até aqui, sem código, apenas conceitos sobre o domínio, sobre o que fazer)


bounded contexts -> 2a parte do livro
se fosse reescrever o livro, o autor iniciaria com base nesta parte


# linguagem ubiqua

- unir conhecimentos dos DEVs com Experts do negócio

cada parte da aplicação chama a msm coisa de um nome diferente


algo que precisa ser definido e acordado com o time todo

ex: modelagem de sistema de vídeo (synchroflix)

conceitos:

playback, video, capa, perfil, lista, titulo, pessoas, genero, catalogo


linguagem a ser utilizada no processo de codificacão


playback: processo de execucão de um video
video: conteudo que sera visto pelo usuario
capa: figura descritiva de um video
perfil: perfil gerado pelo uusario para separar os utilizadores e suas preferencias e "minha lista"
minha lista: lista de videos usada pelo usuario para armazenar o que assistir depois
titulo: nome do video
pessoas: personagens que fazem participacão em um video
genero: classificacão de um video - drama, terror, comedia


quando for falado: melhorar a capa, tds sabem do que se trata
adicionar novos videos, etc



# bounded contexts (contextos delimitados)

- delimita os contextos da aplicacão
- cada contexto possui suas responsabilidades claramente definidas

(contexto de pagamento, contexto de assinatura, contexto de frete)

- cada contexto pode ser sua linguagem ubiqua

(departamento de vendas - cliente é quem contrata serviço)
(departamento de compras - cliente é o próprio usuário que está comprando algo)
(área de vendas - vende para um cliente | compras -> você é o cliente que está comprando algo)
(marketing - cliente é para quem vai a campanha, quem tem qualificacão)
(usabilidade - cliente é quem navega, dá like etc)


é possível ter entidades com o mesmo nome, em contextos diferentes

ex: Cliente

(entidade que pode existir em vários contextos, cada uma com uma implementação diferente)


- forma de definir contexto: utilização de histórias e levantar escopo com um expert de dominio
(falar com quem conhece, pessoas do departamento específico, com o PO etc)


# história:
criar uma conta para acessar o sistema
fazer login
seleciona plano de acesso e faz assinatura
cria perfil de acesso
navega pelo catálogo de videos
realiza busca através do título ou genero
adiciona videos que tem interesse em sua lista
acessa o video escolhido e faz o playback


- definir entidades
- definir ações a serem realizadas pelo sistema


entidades (recebem ou realizam ação)
- conta
- login
- plano
- assinatura
- perfil
- catalogo
- videos
- busca
- titulo
- genero
- videos
- lista
- video
- playback


ações
- cria conta
- faz login
- seleciona plano
- realiza assinatura
- cria perfil
- navega no catálogo
- realiza uma busca
- adiciona videos
- acessa o video


# modelagem

- onde vou definir os contextos a serem utilizados no sistema

dominio principal: video, catalogo
dominio genérico (ajuda no processo, faz com que o dominio principal funcione - sistema poderia funcionar sem ele): pagamento, assinatura, perfil, minha lista
dominio auxiliar (auxilia tudo a funcionar, principais e genericos): autenticacão

razão de existir: ver o catalogo e assistir um video (somente dominios principais)

- catálogo
- video

- assinatura
- pagamento: dominio genérico (ajuda no processo, faz com que o dominio principal funcione)
- perfil
- minha lista

- autenticacão


# context map

- pega os contextos delimitados e monta um mapa de relação entre eles
- organizar da melhor forma possível

catálogo tem relação forte com perfil (catálogo muda de acordo com perfil)
- por ser um dominio principal, o catálogo não muda, as outras entidades é que mudam (perfil)



	 -->

    <script src="assets/reveal.js"></script>
    <script src="assets/plugin/notes/notes.js"></script>
    <script src="assets/plugin/markdown/markdown.js"></script>
    <script src="assets/plugin/highlight/highlight.js"></script>
    <script>
      // More info about initialization & config:
      // - https://revealjs.com/initialization/
      // - https://revealjs.com/config/
      Reveal.initialize({
        hash: true,
        transition: 'convex', // none/fade/slide/convex/concave/zoom

        // Learn about plugins: https://revealjs.com/plugins/
        plugins: [RevealMarkdown, RevealHighlight, RevealNotes],
      });
    </script>
  </body>
</html>
